import { MorseCode, MorseCodeData } from '../models/MorseCode'
import { promptAction } from '@kit.ArkUI'
import { FavoritesStore } from '../store/FavoritesStore'
import { PracticeProgressStore } from '../store/PracticeProgressStore'
import { i18n } from '@kit.LocalizationKit'
// ä½¿ç”¨$r()å‡½æ•°æ›¿ä»£I18n

@Observed
export class PracticeViewModel {
  // Core game state (UI-tracked)
  @Track currentCharacter: string = ''
  @Track currentMorse: string = ''
  @Track userInput: string = ''
  @Track isCorrect: boolean = false
  @Track showResult: boolean = false
  @Track showCorrectAnswer: boolean = false
  @Track showHint: boolean = false
  @Track isFavorite: boolean = false
  @Track hasIncorrectAttempt: boolean = false
  @Track characterChangeId: number = 0
  @Track correctCount: number = 0
  @Track currentCodes: MorseCode[] = []
  @Track completionCount: Map<number, number> = new Map()
  @Track hadIncorrectOnCompletion: Map<number, boolean> = new Map()

  // Internal state
  private checkTimer: number | null = null
  private hintTimer: number | null = null
  private currentIndex: number = 0
  private difficulty: string = 'ç®€å•'
  private favoritesStore: FavoritesStore = FavoritesStore.getInstance()
  private practiceProgressStore: PracticeProgressStore = PracticeProgressStore.getInstance()
  private autoCheckDelay: number = 600

  // Derived values (methods for compatibility with existing pages)
  getProgress(): number {
    // åªæœ‰åœ¨ç”¨æˆ·å‡ºç°é”™è¯¯åæ‰æ˜¾ç¤ºè¿›åº¦ç¯
    // ç¬¬ä¸€æ¬¡æ­£ç¡®ï¼šè¿›åº¦ = 0.5 (åŠåœ†)
    // ç¬¬äºŒæ¬¡æ­£ç¡®ï¼šè¿›åº¦ = 1.0 (å®Œæ•´åœ†)
    if (!this.hasIncorrectAttempt) {
      return 0.0
    }

    // å½“æœ‰é”™è¯¯å°è¯•æ—¶ï¼Œæ ¹æ®æ­£ç¡®æ¬¡æ•°è®¡ç®—è¿›åº¦
    if (this.correctCount === 1) {
      return 0.5 // ç¬¬ä¸€æ¬¡æ­£ç¡®ï¼šå¡«å……åŠåœ†
    } else if (this.correctCount >= 2) {
      return 1.0 // ç¬¬äºŒæ¬¡æ­£ç¡®ï¼šå¡«å……å®Œæ•´åœ†
    }

    return 0.0
  }
  getRequiredAttempts(): number {
    return this.hasIncorrectAttempt ? 2 : 1
  }

  // è·å–å½“å‰å­—ç¬¦çš„è¿ç»­æ­£ç¡®æ¬¡æ•°
  getConsecutiveCorrectCount(): number {
    return this.favoritesStore.getConsecutiveCorrectCount(this.currentCharacter)
  }

  getCharacterChangeId(): number {
    return this.characterChangeId
  }
  // Field accessors (compat methods expected by PracticePage.ets)
  getCurrentCharacter(): string { return this.currentCharacter }
  getCurrentMorse(): string { return this.currentMorse }
  getUserInput(): string { return this.userInput }
  getIsCorrect(): boolean { return this.isCorrect }
  getShowResult(): boolean { return this.showResult }
  getIsFavorite(): boolean { return this.isFavorite }
  getShowCorrectAnswer(): boolean { return this.showCorrectAnswer }
  getHasIncorrectAttempt(): boolean { return this.hasIncorrectAttempt }
  getShowHint(): boolean { return this.showHint }
  getCorrectCount(): number { return this.correctCount }
  getCurrentCodes(): MorseCode[] { return this.currentCodes }
  getCompletionCount(): Map<number, number> { return this.completionCount }
  getHadIncorrectOnCompletion(): Map<number, boolean> { return this.hadIncorrectOnCompletion }

  // Initialize practice session
  init(difficulty: string = 'ç®€å•'): void {
    this.difficulty = difficulty
    this.loadCodes()
  }

  // Initialize with specific characters (for favorites and mistakes)
  initWithCharacters(difficulty: string, characters: string[]): void {
    this.difficulty = difficulty
    this.loadCodesFromCharacters(characters)
  }

  // Load codes based on difficulty
  private loadCodes(): void {
    const d = (this.difficulty || '').toLowerCase()
    // Normalize difficulty: support zh/en labels and code keys
    const isEasy = d === 'easy' || d === 'ç®€å•'
      || d === 'easy'.toLowerCase()
    const isMedium = d === 'medium' || d === 'ä¸­ç­‰'
    const isHard = d === 'hard' || d === 'å›°éš¾'

    if (isEasy) {
      this.currentCodes = MorseCodeData.englishAlphabet
    } else if (isMedium) {
      this.currentCodes = [
        ...MorseCodeData.englishAlphabet,
        ...MorseCodeData.numbers
      ]
    } else if (isHard) {
      // Exclude Chinese characters; include only English letters, numbers, and common symbols
      this.currentCodes = [
        ...MorseCodeData.englishAlphabet,
        ...MorseCodeData.numbers,
        ...MorseCodeData.punctuation,
      ]
    } else {
      // Default fallback
      this.currentCodes = MorseCodeData.englishAlphabet
    }
    this.currentIndex = -1
    this.completionCount = new Map()
    this.hadIncorrectOnCompletion = new Map()
    this.generateNewCharacter()
  }

  // Load codes from specific characters (for favorites and mistakes)
  private loadCodesFromCharacters(characters: string[]): void {
    const allCodes = [...MorseCodeData.englishAlphabet, ...MorseCodeData.numbers, ...MorseCodeData.punctuation]
    this.currentCodes = allCodes.filter(code => characters.includes(code.character))

    this.currentIndex = -1
    this.completionCount = new Map()
    this.hadIncorrectOnCompletion = new Map()
    this.generateNewCharacter()
  }

  // Set current codes (for category filtering)
  setCurrentCodes(codes: MorseCode[]): void {
    this.currentCodes = codes
    this.currentIndex = -1
    this.generateNewCharacter()
  }

  // Generate new character for practice
  generateNewCharacter(): void {
    if (this.currentCodes.length === 0) return

    // ä½¿ç”¨åŠ æƒéšæœºé€‰æ‹©
    this.currentIndex = this.weightedRandomSelection()
    const randomCode = this.currentCodes[this.currentIndex]
    this.currentCharacter = randomCode.character
    this.currentMorse = randomCode.morse
    this.userInput = ''
    this.showResult = false
    this.isCorrect = false
    // åˆå§‹åŒ–æ”¶è—çŠ¶æ€ä¸ºå½“å‰å­—ç¬¦åœ¨æ”¶è—å¤¹ä¸­çš„çœŸå®çŠ¶æ€
    this.isFavorite = this.favoritesStore.isFavorite(this.currentCharacter)
    this.correctCount = 0 // Reset correct count for new character
    this.showCorrectAnswer = false
    this.hasIncorrectAttempt = false // Reset incorrect attempt flag
    this.showHint = false
    this.characterChangeId++ // å¢åŠ å­—ç¬¦å˜åŒ–IDä»¥è§¦å‘åŠ¨ç”»
  }

  // åŠ æƒéšæœºé€‰æ‹©å­—ç¬¦ç´¢å¼•
  private weightedRandomSelection(): number {
    if (this.currentCodes.length === 0) return 0

    // è®¡ç®—æ¯ä¸ªå­—ç¬¦çš„æƒé‡
    const weights: number[] = []
    let totalWeight = 0

    for (const code of this.currentCodes) {
      const weight = this.practiceProgressStore.getCharacterWeight(code.character)
      weights.push(weight)
      totalWeight += weight
    }

    // ä½¿ç”¨æƒé‡è¿›è¡Œéšæœºé€‰æ‹©
    let random = Math.random() * totalWeight
    for (let i = 0; i < weights.length; i++) {
      random -= weights[i]
      if (random <= 0) {
        return i
      }
    }

    // å¤‡ç”¨æ–¹æ¡ˆï¼ˆç†è®ºä¸Šä¸åº”è¯¥åˆ°è¾¾è¿™é‡Œï¼‰
    return Math.floor(Math.random() * this.currentCodes.length)
  }

  // Add dot to user input
  addDot(): void {
    // TODO: Add vibration feedback
    this.userInput += '.'
    this.scheduleAutoCheck()
  }

  // Add dash to user input
  addDash(): void {
    // TODO: Add vibration feedback
    this.userInput += '-'
    this.scheduleAutoCheck()
  }

  // Schedule auto-check timer (resets on each input)
  private scheduleAutoCheck(): void {
    if (this.checkTimer !== null) {
      clearTimeout(this.checkTimer)
    }
    this.checkTimer = setTimeout(() => {
      this.checkAnswer()
    }, this.autoCheckDelay)
  }

  // Set auto-check delay for different modes
  setAutoCheckDelay(delay: number): void {
    this.autoCheckDelay = delay
  }

  // Check if the answer is correct
  checkAnswer(): void {
    if (this.userInput.trim() === '') return

    const isCorrect = this.userInput.trim() === this.currentMorse
    this.isCorrect = isCorrect
    this.showResult = true

    if (isCorrect) {
      this.correctCount++
      const requiredCount = this.hasIncorrectAttempt ? 2 : 1

      // è®°å½•æ­£ç¡®ç­”æ¡ˆåˆ°ç»ƒä¹ è¿›åº¦
      this.practiceProgressStore.recordCorrect(this.currentCharacter)

      // å¢åŠ è¿ç»­æ­£ç¡®æ¬¡æ•°ï¼ˆä»…åœ¨é”™é¢˜æœ¬ä¸­æ—¶ï¼‰
      if (this.favoritesStore.isMistake(this.currentCharacter)) {
        const consecutiveCount = this.favoritesStore.incrementConsecutiveCorrect(this.currentCharacter)
        console.log(`Character ${this.currentCharacter} consecutive correct: ${consecutiveCount}`)

        // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä»é”™é¢˜æœ¬ç§»é™¤
        if (this.favoritesStore.tryRemoveFromMistakes(this.currentCharacter)) {
          console.log(`Character ${this.currentCharacter} removed from mistakes after 3 consecutive correct answers`)
          // æ˜¾ç¤ºç§»é™¤æç¤º
          try {
            const currentLocale = i18n.System.getSystemLocale()
            const message = currentLocale.startsWith('zh')
              ? `ğŸ‰ ${this.currentCharacter} å·²ä»é”™é¢˜æœ¬ç§»é™¤ï¼`
              : `ğŸ‰ ${this.currentCharacter} Removed from mistakes!`
            promptAction.showToast({
              message: message,
              duration: 2000,
              bottom: '70%'
            })
          } catch (error) {
            console.error('[PracticeViewModel] Failed to show toast:', error)
          }
        }
      }

      if (this.correctCount >= requiredCount) {
        // Character completed, move to next
        // Mark this character as practiced in this session
        if (this.currentIndex >= 0) {
          const currentCount = this.completionCount.get(this.currentIndex) || 0
          this.completionCount.set(this.currentIndex, currentCount + 1)
          // Record whether this completion had an incorrect attempt beforehand
          this.hadIncorrectOnCompletion.set(this.currentIndex, this.hasIncorrectAttempt)
        }

        setTimeout(() => {
          this.generateNewCharacter()
        }, 1500)
      } else {
        // Need more correct attempts, reset for next attempt
        setTimeout(() => {
          this.userInput = ''
          this.showResult = false
          this.isCorrect = false
        }, 1500)
      }
    } else {
      // è®°å½•é”™è¯¯ç­”æ¡ˆåˆ°ç»ƒä¹ è¿›åº¦
      this.practiceProgressStore.recordIncorrect(this.currentCharacter)

      // Wrong answer, show system toast at top of screen
      try {
        const currentLocale = i18n.System.getSystemLocale()
        const message = currentLocale.startsWith('zh') ? 'å†è¯•ä¸€æ¬¡' : 'Try again'
        promptAction.showToast({
          message: message,
          duration: 1500,
          bottom: '80%'
        })
      } catch (error) {
        console.error('[PracticeViewModel] Failed to show toast:', error)
      }

      // Add to mistakes if not already there
      this.favoritesStore.addToMistakes(this.currentCharacter)

      // é‡ç½®è¿ç»­æ­£ç¡®æ¬¡æ•°ï¼ˆå› ä¸ºç­”é”™äº†ï¼‰
      this.favoritesStore.resetConsecutiveCorrect(this.currentCharacter)

      // Mark that user made incorrect attempt (if not already marked)
      if (!this.hasIncorrectAttempt) {
        this.hasIncorrectAttempt = true
        this.correctCount = 0 // Only reset counter on first incorrect attempt
      }

      // After 500ms, show correct answer
      setTimeout(() => {
        this.showCorrectAnswer = true
      }, 500)

      // Auto-hide error state after 2 seconds total (500ms red + 1.5s correct answer)
      setTimeout(() => {
        this.showResult = false
        this.showCorrectAnswer = false
        this.userInput = ''
      }, 2000)
    }
  }

  // Clear user input
  clearInput(): void {
    this.userInput = ''
  }

  // Toggle favorite status (sync with store state)
  toggleFavorite(): void {
    this.isFavorite = this.favoritesStore.isFavorite(this.currentCharacter)
  }

  // Skip to next character
  passCharacter(): void {
    this.generateNewCharacter()
  }

  // Play morse code audio
  playMorseCode(): void {
    // TODO: Implement audio playback
    console.log(`Playing morse code: ${this.currentMorse}`)
  }

  // Show hint for 1 second
  flashHint(): void {
    if (this.hintTimer !== null) {
      clearTimeout(this.hintTimer)
    }
    this.showHint = true

    this.hintTimer = setTimeout(() => {
      this.showHint = false
    }, 1000)
  }

  // Change difficulty
  changeDifficulty(newDifficulty: string): void {
    if (this.difficulty !== newDifficulty) {
      this.difficulty = newDifficulty
      this.loadCodes()
    }
  }

  // Dispose
  destroy(): void {
    if (this.checkTimer !== null) {
      clearTimeout(this.checkTimer)
    }
    if (this.hintTimer !== null) {
      clearTimeout(this.hintTimer)
    }
  }

  // Backward-compat alias methods for older pages
  initializePractice(difficulty: string): void { this.init(difficulty) }
  dispose(): void { this.destroy() }
}
